<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C 笔记 - The Rust Programming Language</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="ferris.css">
        <link rel="stylesheet" href="theme/2018-edition.css">

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="关于.html">关于</a></li><li class="chapter-item expanded "><a href="C-note.html" class="active"><strong aria-hidden="true">1.</strong> C 笔记</a></li><li class="chapter-item expanded "><a href="none.html"><strong aria-hidden="true">2.</strong> Java 笔记</a></li><li class="chapter-item expanded "><a href="none.html"><strong aria-hidden="true">3.</strong> Mysql 笔记</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="signed和unsigned的混合运算"><a class="header" href="#signed和unsigned的混合运算">signed和unsigned的混合运算</a></h2>
<ol>
<li>先确定数据类型，以大宽度为准。</li>
<li>再确定signed/unsigned；int之下，以大宽度前面的符号为准；int及以上，若有unsigned，则已unsigned为准。</li>
</ol>
<h2 id="函数"><a class="header" href="#函数">函数</a></h2>
<p><font color="red"></font></p>
<ul>
<li>调用函数时，不管传入的是什么类型，函数的参数和返回值会自动转成函数定义里指定的类型。</li>
<li>如果函数没有返回值，可以省略<code>return</code>语句，或者写成<code>return;</code>。</li>
<li>对于main()，C 语言约定，返回值<code>0</code>表示函数运行成功，如果返回其他非零整数，就表示运行失败。系统根据<code>main()</code>的返回值，作为整个程序的返回值，确定程序是否运行成功。</li>
<li><code>extern</code>说明该函数的定义来自其他文件。
<strong>函数不要返回内部变量的指针。</strong> 因为当函数结束运行时，内部变量就消失了，这时指向内部变量<code>i</code>的内存地址就是无效的，再去使用这个地址是非常危险的。</li>
</ul>
<pre><code class="language-C">int* f(void) {
  int i;
  // ...
  return &amp;i;
}
</code></pre>
<h3 id="函数原型"><a class="header" href="#函数原型">函数原型</a></h3>
<p>函数原型包括参数名也可以，虽然这样对于编译器是多余的，但是阅读代码的时候，可能有助于理解函数的意图。</p>
<pre><code class="language-C">int twice(int);

// 等同于
int twice(int num);
</code></pre>
<h3 id="exit函数"><a class="header" href="#exit函数">exit()函数</a></h3>
<p><code>exit()</code>函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件<code>stdlib.h</code>里面。</p>
<p><code>exit()</code>可以向程序外部返回一个值，它的参数就是程序的返回值。一般来说，使用两个常量作为它的参数：<code>EXIT_SUCCESS</code>（相当于 0）表示程序运行成功，<code>EXIT_FAILURE</code>（相当于 1）表示程序异常中止。这两个常数也是定义在<code>stdlib.h</code>里面。</p>
<pre><code class="language-C">// 程序运行成功
// 等同于 exit(0);
exit(EXIT_SUCCESS);

// 程序异常中止
// 等同于 exit(1);
exit(EXIT_FAILURE);
</code></pre>
<p>在<code>main()</code>函数里面，<code>exit()</code>等价于使用<code>return</code>语句；其他函数使用<code>exit()</code>，就是终止整个程序的运行，没有其它作用。</p>
<p>C 语言还提供了一个<code>atexit()</code>函数，用来登记<code>exit()</code>执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件<code>stdlib.h</code>；</p>
<p><code>atexit()</code>的参数是一个函数指针。注意，它的参数函数（下例的<code>print</code>）不能接收参数，也不能有返回值。</p>
<pre><code class="language-C">void print(void) {
  printf(&quot;something wrong!\n&quot;);
}

atexit(print);
exit(EXIT_FAILURE);
// `exit()`执行时会先自动调用`atexit()`注册的`print()`函数，然后再终止程序。
</code></pre>
<h3 id="函数指针"><a class="header" href="#函数指针">函数指针</a></h3>
<p>函数本身就是一段内存里面的代码，C语言允许通过指针获取函数。</p>
<pre><code class="language-C">void print(int a) {
  printf(&quot;%d\n&quot;, a);
}

void (*print_ptr)(int) = &amp;print;
// 变量`print_ptr`是一个函数指针，它指向函数`print()`的地址。函数`print()`的地址可以用`&amp;print`获得。注意，`(*print_ptr)`一定要写在圆括号里面，否则函数参数`(int)`的优先级高于`*`，整个式子就会变成`void* print_ptr(int)`。

// 有了函数指针，通过它也可以调用函数
(*print_ptr)(10); 
// 等同于
print(10);
</code></pre>
<p>比较特殊的是，C 语言还规定，<strong>函数名本身就是指向函数代码的指针</strong>，通过函数名就能获取函数地址。也就是说，<code>print</code>和<code>&amp;print</code>是一回事。<code>if (print == &amp;print)</code> 结果为<code>true</code>。</p>
<p>所以，对于任意函数，都有五种调用函数的写法。</p>
<pre><code class="language-C">print(10) // 写法1
(*print)(10) // 写法2
(&amp;print)(10) // 写法3
(*print_ptr)(10) // 写法4
print_ptr(10) // 写法5
</code></pre>
<p>为了简洁易读，一般情况下，函数名前面都不加<code>*</code>和<code>&amp;</code>。</p>
<pre><code class="language-C">// 当一个函数的参数或返回值也是一个函数时；
int compute(int (*myfunc)(int), int, int); // 这是一个函数原型
// 函数`compute()`的第一个参数也是一个函数。
</code></pre>
<h3 id="static-说明符"><a class="header" href="#static-说明符">static 说明符</a></h3>
<p><code>static</code>用于函数内部声明变量时，表示该变量只需要初始化一次，每次调用时都会使用上一次的值。注意，<code>static</code>修饰的变量初始化时，只能赋值为常量，不能赋值为变量。</p>
<pre><code class="language-C">// 在块作用域中，`static`声明的变量有默认值`0`。
static int a;
// 等同于
static int a = 0;
</code></pre>
<p><code>static</code>可以修饰函数时，表示该函数只能在当前文件里使用，如果没有这个关键字，其他文件也可以使用这个函数（通过声明函数原型）。</p>
<pre><code class="language-C">static void test(void) {
    //...    
 
</code></pre>
<p><code>static</code>也可以用在参数里面，修饰参数数组。</p>
<pre><code class="language-C">int sum_array(int a[static 3], int n) {
  // ...
}

// 该示例中，`static`对程序行为不会有任何影响，只是用来告诉编译器，该数组长度至少为3，某些情况下可以加快程序运行速度。另外，需要注意的是，对于多维数组的参数，`static`仅可用于第一维的说明。
</code></pre>
<h3 id="const-说明符"><a class="header" href="#const-说明符">const 说明符</a></h3>
<p>函数参数里面的<code>const</code>说明符，表示函数内部不得修改该参数变量。<br />
以下是const的不同位置的不同效果：</p>
<pre><code class="language-C">// 限制 *p
void f(const int* p) {
  int a = 12;
  *p = 0; // 报错，指针指向的值不能修改
  p = &amp;a; // 正确，指针指向的地址可以修改
}
</code></pre>
<pre><code class="language-C">// 限制 p
void f(int* const p) {
  int a = 12;
  *p = 12; // 正确
  p = &amp;a; // 报错
}
</code></pre>
<pre><code class="language-C">// 限制 *p 和 p
void f(const int* const p) {
  int a = 12;
  *p = 12; // 报错
  p = &amp;a; // 报错
}
</code></pre>
<h2 id="指针"><a class="header" href="#指针">指针</a></h2>
<h3 id="指针变量的初始化"><a class="header" href="#指针变量的初始化">指针变量的初始化</a></h3>
<p>声明指针变量之后，编译器会为指针变量本身分配一个随机的内存空间，指针变量指向的值是随机的。这时<strong>一定不能去读写指针变量指向的地址</strong>，因为那个地址是随机地址，很可能会导致严重后果。</p>
<pre><code class="language-C">int* p;
*p = 1; // 错误
</code></pre>
<p>正确做法是指针变量声明后，必须先让它指向一个分配好的地址，然后再进行读写，这叫做指针变量的初始化。</p>
<pre><code class="language-C">int* p;
int i;

p = &amp;i; // 指向一个分配好的地址
*p = 12;
</code></pre>
<p>为了防止读写未初始化的指针变量，可以养成习惯，将未初始化的指针变量设为<code>NULL</code>。</p>
<pre><code class="language-C">int* p = NULL;
</code></pre>
<p><code>NULL</code>在 C 语言中是一个常量，表示地址为<code>0</code>的内存空间，该地址是无法使用的，读写该地址会报错。</p>
<h3 id="指针的运算"><a class="header" href="#指针的运算">指针的运算</a></h3>
<p>指针本质上就是一个无符号整数，代表了内存地址。它可以进行运算，但是规则并不是整数运算的规则。</p>
<ol>
<li>指针与整数值的加减运算<br />
指针与整数值的运算，表示指针的移动。</li>
</ol>
<pre><code class="language-C">short* j;
j = (short*)0x1234;
j = j + 1; // 0x1236
// `j + 1`表示指针向内存地址的高位移动一个单位，而一个单位的`short`类型占据两个字节的宽度，所以相当于向高位移动两个字节。
</code></pre>
<ol start="2">
<li>
<p>指针与指针的加法运算<br />
<strong>指针只能与整数值进行加减运算，两个指针进行加法是非法的</strong>。</p>
</li>
<li>
<p>指针与指针的减法<br />
相同类型的指针允许进行减法运算，返回它们之间的距离，即相隔多少个数据单位。<br />
高位地址减去低位地址，返回的是正值；低位地址减去高位地址，返回的是负值。<br />
这时，减法返回的值属于<code>ptrdiff_t</code>类型，这是一个带符号的整数类型别名，具体类型根据系统不同而不同。这个类型的原型定义在头文件<code>stddef.h</code>里面。</p>
</li>
</ol>
<pre><code class="language-C">short* j1;
short* j2;

j1 = (short*)0x1234;
j2 = (short*)0x1236;

ptrdiff_t dist = j2 - j1;
printf(&quot;%td\n&quot;, dist); // 1
</code></pre>
<p>上面示例中，<code>j1</code>和<code>j2</code>是两个指向 short 类型的指针，变量<code>dist</code>是它们之间的距离，类型为<code>ptrdiff_t</code>，值为<code>1</code>，因为相差2个字节正好存放一个 short 类型的值。</p>
<ol start="4">
<li>指针与指针的比较运算<br />
指针之间的比较运算，比较的是各自的内存地址哪一个更大，返回值是整数<code>1</code>(true)或<code>0</code>(false)。</li>
</ol>
<h3 id="指针与基本类型的转换"><a class="header" href="#指针与基本类型的转换">指针与基本类型的转换</a></h3>
<pre><code class="language-C">int a = 10;
void *b = (void *)((intptr_t)a);
int c = (int)((intptr_t)b);
a == b // true
本质都是传递a值的二进制数据，类型强转只是为了骗过编译器
</code></pre>
<h2 id="数组"><a class="header" href="#数组">数组</a></h2>
<h3 id="数组指针运算"><a class="header" href="#数组指针运算">数组指针运算</a></h3>
<p>...</p>
<h2 id="字符串"><a class="header" href="#字符串">字符串</a></h2>
<p>字符串变量可以声明成一个字符数组，也可以声明成一个指针，指向字符数组。</p>
<pre><code class="language-C">char s[14] = &quot;Hello, world!&quot;; // 写法1，字符数组
char s[] = &quot;Hello, world!&quot;; // 同上，编译器自动计算长度
s[1] = 'A'; // 可修改
char* s = &quot;Hello, world!&quot;; // 写法3，字符指针
</code></pre>
<p>字符指针和字符数组，这两种声明字符串变量的写法基本是等价的，<strong>但是有两个差异：</strong></p>
<ol>
<li>第一个差异是，指针指向的字符串字面量，在 C 语言内部被当作<strong>常量</strong>，不能修改字符串本身。</li>
</ol>
<pre><code class="language-C">char* s = &quot;Hello, world!&quot;;
s[0] = 'z'; // 错误
</code></pre>
<p><em>声明为指针时</em>，系统会将字符串字面量保存在内存的常量区，这个区是不允许用户修改的；<em>声明为数组时</em>，编译器会给数组单独分配一段内存，字符串字面量会被编译器解释成字符数组，逐个字符写入新分配的内存之中，而这段新内存是允许修改的。</p>
<pre><code class="language-C">// 为了提醒用户，可以使用`const`说明符，保证该字符串是只读的，一旦修改，编译器肯定会报错。
const char* s = &quot;Hello, world!&quot;;
</code></pre>
<ol start="2">
<li>第二个差异是，<strong>指针变量可以指向其它字符串</strong>。</li>
</ol>
<pre><code class="language-C">char* s = &quot;hello&quot;;
s = &quot;world&quot;;
</code></pre>
<p>但是，<strong>字符数组变量不能指向另一个字符串</strong>。
字符数组的数组名，总是指向初始化时的字符串地址，不能修改。</p>
<p>字符数组的长度，可以大于（但不能小于）字符串的实际长度。</p>
<pre><code class="language-C">// 空出来的位置会被初始化为`\0`。
char s[50] = &quot;hello&quot;;
</code></pre>
<h2 id="struct"><a class="header" href="#struct">struct</a></h2>
<p>struct 结构占用的存储空间，是<strong>最大内存占用属性的存储空间的倍数</strong>，其他属性会添加空位与之对齐，这样可以提高读写效率。(为了加快读写速度，把内存占用划分成等长的区块，就可以快速在 Struct 结构体中定位到每个属性的起始地址。)</p>
<pre><code class="language-C">struct foo {
  int a;        // 4
  char pad1[4]; // 填充4字节
  char *b;      // 8
  char c;       // 1
  char pad2[7]; // 填充7字节
};
printf(&quot;%d\n&quot;, sizeof(struct foo)); // 24
</code></pre>
<p>由于这个特性，在有必要的情况下，定义 Struct 结构体时，可以采用<strong>存储空间递增的顺序</strong>，定义每个属性，这样就能<strong>节省一些空间</strong>。</p>
<pre><code class="language-C">struct foo {
  char c;
  int a;
  char* b;
};
printf(&quot;%d\n&quot;, sizeof(struct foo)); // 16
</code></pre>
<p>上面示例中，占用空间最小的<code>char c</code>排在第一位，其次是<code>int a</code>，占用空间最大的<code>char* b</code>排在最后。整个<code>strct foo</code>的内存占用就从24字节下降到16字节。</p>
<h3 id="struct-的复制"><a class="header" href="#struct-的复制">struct 的复制</a></h3>
<p>struct 变量可以使用赋值运算符（<code>=</code>），复制给另一个 struct 变量，这时会<strong>生成一个全新的副本</strong>，而不仅仅是修改指向的内存地址。这一点跟数组的复制不一样。</p>
<pre><code class="language-C">struct cat {char name[30], int age} a, b;
strcpy(name, &quot;AR&quot;);
a.age = 100;

b = a; // 复制后，a与b的值是各自独立的
b.name[0] = 'V';

printf(&quot;%s&quot;, a.name); // AR
printf(&quot;%s&quot;, b.name); // VR
</code></pre>
<h3 id="struct-指针"><a class="header" href="#struct-指针">struct 指针</a></h3>
<p>如果将 struct 变量传入函数，函数内部得到的是一个原始值的副本。
通过struct 指针获取属性值：</p>
<pre><code class="language-C">struct trutle {...}

void happy(struct turtle* t) {
  (*t).age = (*t).age + 1; // 写法1
  t-&gt;age = t-&gt;age + 1 // 写法2
}
</code></pre>
<h3 id="位字段"><a class="header" href="#位字段">位字段</a></h3>
<p>struct 还可以用来定义二进制位组成的数据结构，称为“位字段”（bit field），这对于操作底层的二进制数据非常有用。</p>
<h2 id="变量说明符"><a class="header" href="#变量说明符">变量说明符</a></h2>
<h3 id="const"><a class="header" href="#const">const</a></h3>
<p>对于指针变量，<code>const</code>有两种写法，含义是不一样的。</p>
<pre><code class="language-C">// const 表示地址所在的值不能修改(数据不能修改)
int const *x
// 或者
const int* x

*x = 100; // 报错
</code></pre>
<pre><code class="language-C">// const 表示x指向的地址不能修改(指向不能修改)
int* const x

x = &amp;100; // 报错
</code></pre>
<p>如果一个指针变量指向<code>const</code>变量，那么该指针变量也不应该被修改。</p>
<pre><code class="language-C">const int i = 1;
int* j = &amp;i;
*j = 2; // 报错
</code></pre>
<h3 id="extern"><a class="header" href="#extern">extern</a></h3>
<p>变量声明时，同时进行初始化，<code>extern</code>就会无效，是为了防止多个<code>extern</code>对同一个变量进行多次初始化。</p>
<pre><code class="language-C">// extern 无效
extern int i = 0;

// 等同于
int i = 0;
</code></pre>
<p>函数内部使用<code>extern</code>声明变量，就相当于该变量是静态存储，每次执行时都要从外部获取它的值。</p>
<p>函数本身默认是<code>extern</code>，即该函数可以被外部文件共享，通常省略<code>extern</code>不写。如果只希望函数在当前文件可用，那就需要在函数前面加上<code>static</code>。</p>
<h2 id="运算符"><a class="header" href="#运算符">运算符</a></h2>
<h3 id="求模运算符"><a class="header" href="#求模运算符">求模运算符：%</a></h3>
<p><em>(C99)</em> 负数求模，求模结果的正负和第一个运算对象的正负相同；例：8%-3为2，-8%3为-2，-8%-3为-2；
标准规定，只要a和b是整数，都可以通过<code>a-(a\b)*b</code>求得a%b;</p>
<h2 id="图片测试"><a class="header" href="#图片测试">图片测试</a></h2>
<h3 id="image1"><a class="header" href="#image1">image1</a></h3>
<p>img01:
<img src="img/20220626_074419.jpg" alt="20220626_074419" /></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="关于.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="none.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="关于.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="none.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="ferris.js"></script>


    </div>
    </body>
</html>
