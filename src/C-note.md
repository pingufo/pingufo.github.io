## signed和unsigned的混合运算
1. 先确定数据类型，以大宽度为准。
2. 再确定signed/unsigned；int之下，以大宽度前面的符号为准；int及以上，若有unsigned，则已unsigned为准。
## 函数
<font color="red"></font>
* 调用函数时，不管传入的是什么类型，函数的参数和返回值会自动转成函数定义里指定的类型。
* 如果函数没有返回值，可以省略`return`语句，或者写成`return;`。
* 对于main()，C 语言约定，返回值`0`表示函数运行成功，如果返回其他非零整数，就表示运行失败。系统根据`main()`的返回值，作为整个程序的返回值，确定程序是否运行成功。
* `extern`说明该函数的定义来自其他文件。
**函数不要返回内部变量的指针。** 因为当函数结束运行时，内部变量就消失了，这时指向内部变量`i`的内存地址就是无效的，再去使用这个地址是非常危险的。
```C
int* f(void) {
  int i;
  // ...
  return &i;
}
```
### 函数原型
函数原型包括参数名也可以，虽然这样对于编译器是多余的，但是阅读代码的时候，可能有助于理解函数的意图。
```C
int twice(int);

// 等同于
int twice(int num);
```
### exit()函数
`exit()`函数用来终止整个程序的运行。一旦执行到该函数，程序就会立即结束。该函数的原型定义在头文件`stdlib.h`里面。

`exit()`可以向程序外部返回一个值，它的参数就是程序的返回值。一般来说，使用两个常量作为它的参数：`EXIT_SUCCESS`（相当于 0）表示程序运行成功，`EXIT_FAILURE`（相当于 1）表示程序异常中止。这两个常数也是定义在`stdlib.h`里面。
```C
// 程序运行成功
// 等同于 exit(0);
exit(EXIT_SUCCESS);

// 程序异常中止
// 等同于 exit(1);
exit(EXIT_FAILURE);
```
在`main()`函数里面，`exit()`等价于使用`return`语句；其他函数使用`exit()`，就是终止整个程序的运行，没有其它作用。

C 语言还提供了一个`atexit()`函数，用来登记`exit()`执行时额外执行的函数，用来做一些退出程序时的收尾工作。该函数的原型也是定义在头文件`stdlib.h`；  

`atexit()`的参数是一个函数指针。注意，它的参数函数（下例的`print`）不能接收参数，也不能有返回值。

```C
void print(void) {
  printf("something wrong!\n");
}

atexit(print);
exit(EXIT_FAILURE);
// `exit()`执行时会先自动调用`atexit()`注册的`print()`函数，然后再终止程序。
```
### 函数指针
函数本身就是一段内存里面的代码，C语言允许通过指针获取函数。
```C
void print(int a) {
  printf("%d\n", a);
}

void (*print_ptr)(int) = &print;
// 变量`print_ptr`是一个函数指针，它指向函数`print()`的地址。函数`print()`的地址可以用`&print`获得。注意，`(*print_ptr)`一定要写在圆括号里面，否则函数参数`(int)`的优先级高于`*`，整个式子就会变成`void* print_ptr(int)`。

// 有了函数指针，通过它也可以调用函数
(*print_ptr)(10); 
// 等同于
print(10);
```
比较特殊的是，C 语言还规定，**函数名本身就是指向函数代码的指针**，通过函数名就能获取函数地址。也就是说，`print`和`&print`是一回事。`if (print == &print)` 结果为`true`。  

所以，对于任意函数，都有五种调用函数的写法。
```C
print(10) // 写法1
(*print)(10) // 写法2
(&print)(10) // 写法3
(*print_ptr)(10) // 写法4
print_ptr(10) // 写法5
```

为了简洁易读，一般情况下，函数名前面都不加`*`和`&`。
```C
// 当一个函数的参数或返回值也是一个函数时；
int compute(int (*myfunc)(int), int, int); // 这是一个函数原型
// 函数`compute()`的第一个参数也是一个函数。
```
### static 说明符
`static`用于函数内部声明变量时，表示该变量只需要初始化一次，每次调用时都会使用上一次的值。注意，`static`修饰的变量初始化时，只能赋值为常量，不能赋值为变量。
```C
// 在块作用域中，`static`声明的变量有默认值`0`。
static int a;
// 等同于
static int a = 0;
```
`static`可以修饰函数时，表示该函数只能在当前文件里使用，如果没有这个关键字，其他文件也可以使用这个函数（通过声明函数原型）。
```C
static void test(void) {
    //...    
 
```

`static`也可以用在参数里面，修饰参数数组。
```C
int sum_array(int a[static 3], int n) {
  // ...
}

// 该示例中，`static`对程序行为不会有任何影响，只是用来告诉编译器，该数组长度至少为3，某些情况下可以加快程序运行速度。另外，需要注意的是，对于多维数组的参数，`static`仅可用于第一维的说明。
```
### const 说明符
函数参数里面的`const`说明符，表示函数内部不得修改该参数变量。  
以下是const的不同位置的不同效果：
```C
// 限制 *p
void f(const int* p) {
  int a = 12;
  *p = 0; // 报错，指针指向的值不能修改
  p = &a; // 正确，指针指向的地址可以修改
}
```

```C
// 限制 p
void f(int* const p) {
  int a = 12;
  *p = 12; // 正确
  p = &a; // 报错
}
```

```C
// 限制 *p 和 p
void f(const int* const p) {
  int a = 12;
  *p = 12; // 报错
  p = &a; // 报错
}
```
## 指针
### 指针变量的初始化
声明指针变量之后，编译器会为指针变量本身分配一个随机的内存空间，指针变量指向的值是随机的。这时**一定不能去读写指针变量指向的地址**，因为那个地址是随机地址，很可能会导致严重后果。
```C
int* p;
*p = 1; // 错误
```
正确做法是指针变量声明后，必须先让它指向一个分配好的地址，然后再进行读写，这叫做指针变量的初始化。
```C
int* p;
int i;

p = &i; // 指向一个分配好的地址
*p = 12;
```
为了防止读写未初始化的指针变量，可以养成习惯，将未初始化的指针变量设为`NULL`。

```C
int* p = NULL;
```

`NULL`在 C 语言中是一个常量，表示地址为`0`的内存空间，该地址是无法使用的，读写该地址会报错。
### 指针的运算
指针本质上就是一个无符号整数，代表了内存地址。它可以进行运算，但是规则并不是整数运算的规则。

1. 指针与整数值的加减运算  
指针与整数值的运算，表示指针的移动。
```C
short* j;
j = (short*)0x1234;
j = j + 1; // 0x1236
// `j + 1`表示指针向内存地址的高位移动一个单位，而一个单位的`short`类型占据两个字节的宽度，所以相当于向高位移动两个字节。
```
2. 指针与指针的加法运算  
**指针只能与整数值进行加减运算，两个指针进行加法是非法的**。

3. 指针与指针的减法  
相同类型的指针允许进行减法运算，返回它们之间的距离，即相隔多少个数据单位。  
高位地址减去低位地址，返回的是正值；低位地址减去高位地址，返回的是负值。  
这时，减法返回的值属于`ptrdiff_t`类型，这是一个带符号的整数类型别名，具体类型根据系统不同而不同。这个类型的原型定义在头文件`stddef.h`里面。
```C
short* j1;
short* j2;

j1 = (short*)0x1234;
j2 = (short*)0x1236;

ptrdiff_t dist = j2 - j1;
printf("%td\n", dist); // 1
```
上面示例中，`j1`和`j2`是两个指向 short 类型的指针，变量`dist`是它们之间的距离，类型为`ptrdiff_t`，值为`1`，因为相差2个字节正好存放一个 short 类型的值。

4. 指针与指针的比较运算  
指针之间的比较运算，比较的是各自的内存地址哪一个更大，返回值是整数`1`(true)或`0`(false)。
### 指针与基本类型的转换
```C
int a = 10;
void *b = (void *)((intptr_t)a);
int c = (int)((intptr_t)b);
a == b // true
本质都是传递a值的二进制数据，类型强转只是为了骗过编译器
```
## 数组
### 数组指针运算
...
## 字符串
字符串变量可以声明成一个字符数组，也可以声明成一个指针，指向字符数组。
```C
char s[14] = "Hello, world!"; // 写法1，字符数组
char s[] = "Hello, world!"; // 同上，编译器自动计算长度
s[1] = 'A'; // 可修改
char* s = "Hello, world!"; // 写法3，字符指针
```
字符指针和字符数组，这两种声明字符串变量的写法基本是等价的，**但是有两个差异：**
1. 第一个差异是，指针指向的字符串字面量，在 C 语言内部被当作**常量**，不能修改字符串本身。
```C
char* s = "Hello, world!";
s[0] = 'z'; // 错误
```
*声明为指针时*，系统会将字符串字面量保存在内存的常量区，这个区是不允许用户修改的；*声明为数组时*，编译器会给数组单独分配一段内存，字符串字面量会被编译器解释成字符数组，逐个字符写入新分配的内存之中，而这段新内存是允许修改的。
```C
// 为了提醒用户，可以使用`const`说明符，保证该字符串是只读的，一旦修改，编译器肯定会报错。
const char* s = "Hello, world!";
```
2. 第二个差异是，**指针变量可以指向其它字符串**。
```C
char* s = "hello";
s = "world";
```
但是，**字符数组变量不能指向另一个字符串**。
字符数组的数组名，总是指向初始化时的字符串地址，不能修改。

字符数组的长度，可以大于（但不能小于）字符串的实际长度。
```C
// 空出来的位置会被初始化为`\0`。
char s[50] = "hello";
```
## struct
struct 结构占用的存储空间，是**最大内存占用属性的存储空间的倍数**，其他属性会添加空位与之对齐，这样可以提高读写效率。(为了加快读写速度，把内存占用划分成等长的区块，就可以快速在 Struct 结构体中定位到每个属性的起始地址。)
```C
struct foo {
  int a;        // 4
  char pad1[4]; // 填充4字节
  char *b;      // 8
  char c;       // 1
  char pad2[7]; // 填充7字节
};
printf("%d\n", sizeof(struct foo)); // 24
```

由于这个特性，在有必要的情况下，定义 Struct 结构体时，可以采用**存储空间递增的顺序**，定义每个属性，这样就能**节省一些空间**。
```C
struct foo {
  char c;
  int a;
  char* b;
};
printf("%d\n", sizeof(struct foo)); // 16
```
上面示例中，占用空间最小的`char c`排在第一位，其次是`int a`，占用空间最大的`char* b`排在最后。整个`strct foo`的内存占用就从24字节下降到16字节。
### struct 的复制
struct 变量可以使用赋值运算符（`=`），复制给另一个 struct 变量，这时会**生成一个全新的副本**，而不仅仅是修改指向的内存地址。这一点跟数组的复制不一样。
```C
struct cat {char name[30], int age} a, b;
strcpy(name, "AR");
a.age = 100;

b = a; // 复制后，a与b的值是各自独立的
b.name[0] = 'V';

printf("%s", a.name); // AR
printf("%s", b.name); // VR
```
### struct 指针
如果将 struct 变量传入函数，函数内部得到的是一个原始值的副本。
通过struct 指针获取属性值：
```C
struct trutle {...}

void happy(struct turtle* t) {
  (*t).age = (*t).age + 1; // 写法1
  t->age = t->age + 1 // 写法2
}
```
### 位字段
struct 还可以用来定义二进制位组成的数据结构，称为“位字段”（bit field），这对于操作底层的二进制数据非常有用。
## 变量说明符
### const
对于指针变量，`const`有两种写法，含义是不一样的。
```C
// const 表示地址所在的值不能修改(数据不能修改)
int const *x
// 或者
const int* x

*x = 100; // 报错
```

```C
// const 表示x指向的地址不能修改(指向不能修改)
int* const x

x = &100; // 报错
```
如果一个指针变量指向`const`变量，那么该指针变量也不应该被修改。
```C
const int i = 1;
int* j = &i;
*j = 2; // 报错
```
### extern
变量声明时，同时进行初始化，`extern`就会无效，是为了防止多个`extern`对同一个变量进行多次初始化。
```C
// extern 无效
extern int i = 0;

// 等同于
int i = 0;
```
函数内部使用`extern`声明变量，就相当于该变量是静态存储，每次执行时都要从外部获取它的值。

函数本身默认是`extern`，即该函数可以被外部文件共享，通常省略`extern`不写。如果只希望函数在当前文件可用，那就需要在函数前面加上`static`。
## 运算符
### 求模运算符：%
*(C99)* 负数求模，求模结果的正负和第一个运算对象的正负相同；例：8%-3为2，-8%3为-2，-8%-3为-2；
标准规定，只要a和b是整数，都可以通过`a-(a\b)*b`求得a%b;

## 图片测试
### image1
img01:
![20220626_074419](img/20220626_074419.jpg)
